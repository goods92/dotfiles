"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerService = void 0;
const os = require("os");
const fs = require("fs-extra");
const path = require("path");
const bufferShim = require("buffer-shims");
const qr = require("qr-image");
const si = require("systeminformation");
const NodeCache = require("node-cache");
const child_process = require("child_process");
const common_1 = require("@nestjs/common");
const hap_types_1 = require("@oznu/hap-client/dist/hap-types");
const logger_service_1 = require("../../core/logger/logger.service");
const config_service_1 = require("../../core/config/config.service");
const config_editor_service_1 = require("../config-editor/config-editor.service");
const accessories_service_1 = require("../accessories/accessories.service");
let ServerService = class ServerService {
    constructor(configService, configEditorService, accessoriesService, logger) {
        this.configService = configService;
        this.configEditorService = configEditorService;
        this.accessoriesService = accessoriesService;
        this.logger = logger;
        this.serverServiceCache = new NodeCache({ stdTTL: 300 });
        this.accessoryId = this.configService.homebridgeConfig.bridge.username.split(':').join('');
        this.accessoryInfoPath = path.join(this.configService.storagePath, 'persist', `AccessoryInfo.${this.accessoryId}.json`);
    }
    async restartServer() {
        this.logger.log('Homebridge restart request received');
        if (this.configService.serviceMode && !(await this.configService.uiRestartRequired() || await this.nodeVersionChanged())) {
            this.logger.log('UI / Bridge settings have not changed; only restarting Homebridge process');
            process.emit('message', 'restartHomebridge', undefined);
            this.accessoriesService.resetInstancePool();
            return { ok: true, command: 'SIGTERM', restartingUI: false };
        }
        setTimeout(() => {
            if (this.configService.ui.restart) {
                this.logger.log(`Executing restart command: ${this.configService.ui.restart}`);
                child_process.exec(this.configService.ui.restart, (err) => {
                    if (err) {
                        this.logger.log('Restart command exited with an error. Failed to restart Homebridge.');
                    }
                });
            }
            else {
                this.logger.log(`No restart command defined, killing process...`);
                process.kill(process.pid, 'SIGTERM');
            }
        }, 500);
        return { ok: true, command: this.configService.ui.restart, restartingUI: true };
    }
    async resetHomebridgeAccessory() {
        this.configService.hbServiceUiRestartRequired = true;
        const configFile = await this.configEditorService.getConfigFile();
        configFile.bridge.pin = this.configEditorService.generatePin();
        configFile.bridge.username = this.configEditorService.generateUsername();
        this.logger.warn(`Homebridge Reset: New Username: ${configFile.bridge.username}`);
        this.logger.warn(`Homebridge Reset: New Pin: ${configFile.bridge.pin}`);
        await this.configEditorService.updateConfigFile(configFile);
        await fs.remove(path.resolve(this.configService.storagePath, 'accessories'));
        await fs.remove(path.resolve(this.configService.storagePath, 'persist'));
        this.logger.log(`Homebridge Reset: "persist" directory removed.`);
        this.logger.log(`Homebridge Reset: "accessories" directory removed.`);
    }
    async getDevicePairings() {
        const persistPath = path.join(this.configService.storagePath, 'persist');
        const devices = (await fs.readdir(persistPath))
            .filter(x => x.match(/AccessoryInfo\.([A-F,a-f,0-9]+)\.json/));
        return Promise.all(devices.map(async (x) => {
            const device = await fs.readJson(path.join(persistPath, x));
            delete device.signSk;
            delete device.signPk;
            delete device.configHash;
            delete device.setupID;
            device._id = x.split('.')[1];
            device._username = device._id.match(/.{1,2}/g).join(':');
            device._main = this.configService.homebridgeConfig.bridge.username.toUpperCase() === device._username.toUpperCase();
            try {
                device._category = Object.entries(hap_types_1.Categories).find(([name, value]) => value === device.category)[0].toLowerCase();
            }
            catch (e) {
                device._category = 'Other';
            }
            return device;
        }));
    }
    async deleteDevicePairing(id) {
        const persistPath = path.join(this.configService.storagePath, 'persist');
        const accessoryInfo = path.join(persistPath, 'AccessoryInfo.' + id + '.json');
        const identifierCache = path.join(persistPath, 'IdentifierCache.' + id + '.json');
        if (await fs.pathExists(accessoryInfo)) {
            await fs.unlink(accessoryInfo);
            this.logger.warn(`Removed ${accessoryInfo}`);
        }
        if (await fs.pathExists(identifierCache)) {
            await fs.unlink(identifierCache);
            this.logger.warn(`Removed ${identifierCache}`);
        }
        return;
    }
    async getCachedAccessories() {
        const cachedAccessoriesFile = path.join(this.configService.storagePath, 'accessories', 'cachedAccessories');
        if (!await fs.pathExists(cachedAccessoriesFile)) {
            throw new common_1.NotFoundException();
        }
        return await fs.readJson(cachedAccessoriesFile);
    }
    async deleteCachedAccessory(uuid) {
        if (!this.configService.serviceMode) {
            this.logger.error('The reset accessories cache command is only available in service mode');
            throw new common_1.BadRequestException('This command is only available in service mode');
        }
        const cachedAccessoriesPath = path.resolve(this.configService.storagePath, 'accessories', 'cachedAccessories');
        this.logger.warn(`Sent request to hb-service to remove cached accessory with UUID: ${uuid}`);
        return await new Promise((resolve, reject) => {
            process.emit('message', 'deleteSingleCachedAccessory', async () => {
                const cachedAccessories = await this.getCachedAccessories();
                const accessoryIndex = cachedAccessories.findIndex(x => x.UUID === uuid);
                if (accessoryIndex > -1) {
                    cachedAccessories.splice(accessoryIndex, 1);
                    await fs.writeJson(cachedAccessoriesPath, cachedAccessories);
                    this.logger.warn(`Removed cached accessory with UUID: ${uuid}`);
                    resolve();
                }
                else {
                    this.logger.error(`Cannot find cached accessory with UUID: ${uuid}`);
                    reject(new common_1.NotFoundException());
                }
            });
        });
    }
    async resetCachedAccessories() {
        if (!this.configService.serviceMode) {
            this.logger.error('The reset accessories cache command is only available in service mode');
            throw new common_1.BadRequestException('This command is only available in service mode');
        }
        const cachedAccessoriesPath = path.resolve(this.configService.storagePath, 'accessories', 'cachedAccessories');
        this.logger.warn('Sent request to clear cached accesories to hb-service');
        process.emit('message', 'clearCachedAccessories', async () => {
            try {
                if (await fs.pathExists(cachedAccessoriesPath)) {
                    this.logger.log('Clearing Cached Homebridge Accessories...');
                    await fs.unlink(cachedAccessoriesPath);
                    this.logger.warn(`Removed ${cachedAccessoriesPath}`);
                }
            }
            catch (e) {
                this.logger.error(`Failed to clear Homebridge Accessories Cache at ${cachedAccessoriesPath}`);
                console.error(e);
            }
        });
        return;
    }
    async generateQrCode() {
        const setupCode = await this.getSetupCode();
        if (!setupCode) {
            throw new common_1.NotFoundException();
        }
        return qr.image(setupCode, { type: 'svg' });
    }
    async getSetupCode() {
        if (this.setupCode) {
            return this.setupCode;
        }
        else {
            this.setupCode = await this.generateSetupCode();
            return this.setupCode;
        }
    }
    async generateSetupCode() {
        if (!await fs.pathExists(this.accessoryInfoPath)) {
            return null;
        }
        const accessoryInfo = await fs.readJson(this.accessoryInfoPath);
        const buffer = bufferShim.alloc(8);
        const setupCode = parseInt(accessoryInfo.pincode.replace(/-/g, ''), 10);
        let valueLow = setupCode;
        const valueHigh = accessoryInfo.category >> 1;
        valueLow |= 1 << 28;
        buffer.writeUInt32BE(valueLow, 4);
        if (accessoryInfo.category & 1) {
            buffer[4] = buffer[4] | 1 << 7;
        }
        buffer.writeUInt32BE(valueHigh, 0);
        let encodedPayload = (buffer.readUInt32BE(4) + (buffer.readUInt32BE(0) * Math.pow(2, 32))).toString(36).toUpperCase();
        if (encodedPayload.length !== 9) {
            for (let i = 0; i <= 9 - encodedPayload.length; i++) {
                encodedPayload = '0' + encodedPayload;
            }
        }
        return 'X-HM://' + encodedPayload + accessoryInfo.setupID;
    }
    async getBridgePairingInformation() {
        if (!await fs.pathExists(this.accessoryInfoPath)) {
            return new common_1.ServiceUnavailableException('Pairing Information Not Available Yet');
        }
        const accessoryInfo = await fs.readJson(this.accessoryInfoPath);
        return {
            displayName: accessoryInfo.displayName,
            pincode: accessoryInfo.pincode,
            setupCode: await this.getSetupCode(),
            isPaired: accessoryInfo.pairedClients && Object.keys(accessoryInfo.pairedClients).length > 0,
        };
    }
    async getSystemNetworkInterfaces() {
        const fromCache = this.serverServiceCache.get(`network-interfaces`);
        const networkInterfaces = fromCache || (await si.networkInterfaces()).filter((adapter) => {
            return !adapter.internal
                && adapter.mac
                && (adapter.ip4 || (adapter.ip6 && adapter.ip6subnet !== 'ffff:ffff:ffff:ffff::'))
                && (adapter.operstate === 'up' || os.platform() === 'freebsd');
        });
        if (!fromCache) {
            this.serverServiceCache.set(`network-interfaces`, networkInterfaces);
        }
        return networkInterfaces;
    }
    async getHomebridgeNetworkInterfaces() {
        var _a, _b, _c;
        const config = await this.configEditorService.getConfigFile();
        if (!((_a = config.bridge) === null || _a === void 0 ? void 0 : _a.bind)) {
            return [];
        }
        if (Array.isArray((_b = config.bridge) === null || _b === void 0 ? void 0 : _b.bind)) {
            return config.bridge.bind;
        }
        if (typeof ((_c = config.bridge) === null || _c === void 0 ? void 0 : _c.bind) === 'string') {
            return [config.bridge.bind];
        }
        return [];
    }
    async setHomebridgeNetworkInterfaces(adapters) {
        const config = await this.configEditorService.getConfigFile();
        if (!config.bridge) {
            config.bridge = {};
        }
        if (!adapters.length) {
            delete config.bridge.bind;
        }
        else {
            config.bridge.bind = adapters;
        }
        await this.configEditorService.updateConfigFile(config);
        return;
    }
    async nodeVersionChanged() {
        return new Promise((resolve, reject) => {
            let result = false;
            const child = child_process.spawn(process.execPath, ['-v']);
            child.stdout.once('data', (data) => {
                if (data.toString().trim() === process.version) {
                    result = false;
                }
                else {
                    result = true;
                }
            });
            child.on('error', () => {
                result = true;
            });
            child.on('close', () => {
                return resolve(result);
            });
        });
    }
};
ServerService = __decorate([
    common_1.Injectable(),
    __metadata("design:paramtypes", [config_service_1.ConfigService,
        config_editor_service_1.ConfigEditorService,
        accessories_service_1.AccessoriesService,
        logger_service_1.Logger])
], ServerService);
exports.ServerService = ServerService;
//# sourceMappingURL=server.service.js.map